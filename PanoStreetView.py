# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PanoStreetView
                                 A QGIS plugin
 Allows pano street view
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-04-15
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Sachin Kulal
        email                : sachinmk1998@gmail.com/sachin.k@aidash.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon

# Initialize Qt resources from file resources.py
from .resources import *

# Addtional libraries
from qgis.core import *
from qgis.gui import *
from qgis.utils import *
from qgis.PyQt.QtWidgets import QAction, QFileDialog
import math
import json
import webbrowser
from http.server import HTTPServer, SimpleHTTPRequestHandler
from urllib.parse import urlparse
from qgis.PyQt import QtCore
import requests



# global variables
shapefile_path = None
image_folder = None
point_layer = None
index = None
finder = None

HOST, PORT = "", 8030

angle = 0
premuto = False
linea = False

chrome_path = "C:/Program Files/Google/Chrome/Application/chrome.exe"
base_folder = os.path.dirname(os.path.realpath(__file__))

rb = QgsRubberBand(iface.mapCanvas(),QgsWkbTypes.PointGeometry)
marker = QgsVertexMarker(iface.mapCanvas())
rl = QgsRubberBand(iface.mapCanvas(),QgsWkbTypes.LineGeometry)

point0 = iface.mapCanvas().getCoordinateTransform().toMapCoordinates(0, 0)
point1 = iface.mapCanvas().getCoordinateTransform().toMapCoordinates(0, 0)

def read_in_chunks(file_object, chunk_size=None):
    """Read file by chunk index """
    while True:
        data = file_object.read(chunk_size)
        if not data:
            break
        yield data


# Import the code for the DockWidget
from .PanoStreetView_dockwidget import PanoStreetViewDockWidget
import os.path


class PanoStreetView:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'PanoStreetView_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&PanoStreetView')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'PanoStreetView')
        self.toolbar.setObjectName(u'PanoStreetView')

        #print "** INITIALIZING PanoStreetView"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('PanoStreetView', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/PanoStreetView/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'PanoStreetView'),
            callback=self.run,
            parent=self.iface.mainWindow())

    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING PanoStreetView"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD PanoStreetView"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&PanoStreetView'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------
    #function to select the shapefile in widget
    def select_shapefile(self):
        file_name, __filter = QFileDialog.getOpenFileName(
            self.dockwidget, "Select shapefile Path", "", '*.shp'
        )
        if file_name:
            self.dockwidget.le_shp.setText(file_name)
            global shapefile_path, finder
            shapefile_path = file_name
            QgsMessageLog.logMessage("Shapefile selected")
            finder = NearestPointFinder()
            QgsMessageLog.logMessage("Index called")
            

    # funtion to select the image folder
    def select_image_path(self):
        folder_path = QFileDialog.getExistingDirectory(
            self.dockwidget, "Select Images Folder Path"
        )
        if folder_path:
            self.dockwidget.le_img.setText(folder_path)
            global image_folder
            image_folder = folder_path
            QgsMessageLog.logMessage("Image foder selected")

    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING PanoStreetView"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = PanoStreetViewDockWidget()
                
            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.LeftDockWidgetArea, self.dockwidget)
            self.dockwidget.show()

            # add files gui
            self.dockwidget.tb_shp.clicked.connect(self.select_shapefile)
            self.dockwidget.tb_img.clicked.connect(self.select_image_path)

        if shapefile_path and image_folder is not None:
            tool = PointTool(self.iface.mapCanvas())
            self.iface.mapCanvas().setMapTool(tool)
            QgsMessageLog.logMessage("Point tool is called")




# class for event in qgis canvas
class PointTool(QgsMapTool):

        def __init__(self, canvas):
            QgsMapTool.__init__(self, canvas)
            self.canvas = canvas
            self.point_coordinate = None
            self.image_path = None
            

        
        def canvasPressEvent(self, event):
            x = event.pos().x()
            y = event.pos().y()
            global rb, premuto, point0, marker
            if not premuto:
                premuto = True
                rb = QgsRubberBand(iface.mapCanvas(),QgsWkbTypes.PointGeometry)
                rb.setColor(QtCore.Qt.cyan)
                point0 = self.canvas.getCoordinateTransform().toMapCoordinates(x, y)
                rb.addPoint(point0)
                QgsMessageLog.logMessage("First point selected")
                self.point_coordinate = "#" + str(point0)
                QgsMessageLog.logMessage(f"Selected point is {self.point_coordinate}")
                print(f"Selected point is {self.point_coordinate}")
                marker.hide()
                # Set marker as plus symbol
                marker.setCenter(point0)  # Set the center point for the marker
                marker.setColor(QtCore.Qt.red)  # Set the color of the marker (red)
                marker.setIconType(QgsVertexMarker.ICON_CROSS)  # Set the icon type to cross (plus symbol)
                marker.setIconSize(15)  # Adjust the size of the plus symbol as needed
                marker.setPenWidth(2)  # Set the thickness of the marker
                marker.show()
                


        def canvasMoveEvent(self, event):
            x = event.pos().x()
            y = event.pos().y()
            global premuto, point0, point1, linea, rl
            if premuto:
                if not linea:
                    rl.setColor(QtCore.Qt.cyan)
                    point1 = self.canvas.getCoordinateTransform().toMapCoordinates(x, y)
                    rl.reset(QgsWkbTypes.LineGeometry)
                    QgsMessageLog.logMessage("Creating line")
                    rl.addPoint(point0)
                    rl.addPoint(point1)
                    QgsMessageLog.logMessage("End point selected")


        def canvasReleaseEvent(self, event):
            global premuto, linea, rb, rl, point1, point0, angle, image_folder
            angle = math.atan2(point1.x() - point0.x(), point1.y() - point0.y())
            angle = math.degrees(angle)if angle>0 else (math.degrees(angle) + 180) + 180
            premuto = False
            linea = False
            actual_crs = self.canvas.mapSettings().destinationCrs()
            crsDest = QgsCoordinateReferenceSystem.fromEpsgId(4326)
            xform = QgsCoordinateTransform(actual_crs, crsDest, QgsProject.instance())
            pt1 = xform.transform(point0)
            QgsMessageLog.logMessage("Line is released")

            
            img_name, azimuth = finder.find_nearest_point_with_image(self.point_coordinate)

            if not premuto and img_name is not None and image_folder is not None:
                self.image_path = os.path.join(image_folder, img_name)
                QgsMessageLog.logMessage("Name, Path, azimuth, yaw found")
                # Prepare azimuth data to write into JSON file
                azimuth_data = {"azimuth": azimuth, "yaw_value": angle-azimuth}

                # Write azimuth data to a JSON file (overwriting existing content)
                json_file_path = os.path.join(base_folder, 'azimuth_data.json')
                with open(json_file_path, 'w') as json_file:
                    json.dump(azimuth_data, json_file)

                pano = PanoramaViewer(self.image_path)


            rl.reset()
            rb.reset()
            self.point_coordinate = None
            self.image_path = None
            self.canvas.unsetMapTool(self)

        def activate(self):
            pass

        def deactivate(self):
            pass

        def isZoomTool(self):
            return False
        
        def isTransient(self):
            return False
        
        def isEditTool(self):
            return True


class NearestPointFinder:
    def __init__(self):
        global point_layer, index
        point_layer = QgsVectorLayer(shapefile_path, "points", "ogr")
        if not point_layer.isValid():
            raise ValueError("Invalid layer!")
        index = QgsSpatialIndex()
        if point_layer.featureCount() > 0:
            index.addFeatures(point_layer.getFeatures())
        else:
            print("No features found in the point layer.")
            QgsMessageLog.logMessage("No features found in the point layer.")
        print("Index added successfully.")
        QgsMessageLog.logMessage("Index added successfully.")


    def find_nearest_point_with_image(self, point_coordinate):
        if index is None:
            print("Spatial index is not initialized. Call add_index method first.")
            return None, None
        self.coords_str = point_coordinate.split('(')[1].split(')')[0]
        x, y = map(float, self.coords_str.split())
        point = QgsPointXY(x, y)

        nearest_ids = index.nearestNeighbor(point, 1)
        nearest_feature = point_layer.getFeature(nearest_ids[0])
        QgsMessageLog.logMessage("Found nearest image")

        point_name = nearest_feature["Name"]
        azimuth = nearest_feature["Azimuth"]
        print("Nearest image found.")

        return point_name, azimuth


class PanoramaViewer():
    def __init__(self, image_path):
       
        # init settings
        self.wrapper = image_path

        # custom attrs
        self.httpd = None

        
        self.get_pic()
        self.httpd = HttpDaemon(self, base_folder)
        self.httpd.start()
        

    def reset_tr(self):
        """Reset server"""
        if self.httpd:
            self.httpd.stop()


    def get_pic(self):
        """Get pic attrs from selected point and proceed to view panorama"""
        cf_attr = self.wrapper
        result = urlparse(cf_attr)
        img_get = False

        # panorama path check
        if cf_attr and os.path.isfile(cf_attr):
            img_get = GetPanorama(self).get_pano_file(cf_attr, "copy")
            QgsMessageLog.logMessage("Image copied")
        elif all([result.scheme, result.netloc]):
            img_get = GetPanorama(self).get_pano_file(cf_attr, "download")
            QgsMessageLog.logMessage("Image downloaded")
        else:
            pass
        
        # view panorama or not
        if img_get:
            webbrowser.register('chrome', None, webbrowser.BackgroundBrowser(chrome_path))
            ch_url = "http://localhost:8030/index_image.html"
            try:
                webbrowser.get('chrome').open(ch_url)
                QgsMessageLog.logMessage("Image opened in browser")
            except Exception as e:
                print(f"Error opening browser: {e}")
            finally:
                PanoramaViewer.reset_tr(self)
        else:
            webbrowser.register('chrome', None, webbrowser.BackgroundBrowser(chrome_path))
            ch_url = "http://localhost:8030/index_error.html"
            try:
                webbrowser.get('chrome').open(ch_url)
            except Exception as e:
                print(f"Error opening browser: {e}")
            finally:
                PanoramaViewer.reset_tr(self)

        return
    
class GetPanorama():
    """Get panorama image from web or local storage
    depending on method
    """
    def __init__(self, parent):
        super().__init__()
        self.main_app = parent

    def get_pano_file(self, file_url, method):
        """Selecting a method to get an image """
        if method == "download":
            result = self.download(file_url)
        else:
            result = self.copy_file(file_url)
        return result
    
    def download(self, url):
        """Web loader which also writes file chunk by chunk """
        r = requests.get(url, allow_redirects=True, stream=True)
        if r.status_code != 200:
            return False
        total_length = int(r.headers.get("content-length"))
        file_name = os.path.join(base_folder, "image.JPG")
        if total_length: 
            with open(file_name, "wb") as f:
                total_length = int(total_length)
                p_step = 100 / total_length * 4096
                counter = 0
                for data in r.iter_content(chunk_size=4096):
                    counter += p_step
                    f.write(data)
                    QCoreApplication.processEvents()
        return True
    
    def copy_file(self, file_in):
        """File copier, also uses chunk writing method """
        file_out = os.path.join(base_folder, "image.JPG")
        file_stats = os.stat(file_in)
        size_b = file_stats.st_size
        ch_optimal_size = int(size_b / 100)
        p_step = 100 / size_b * ch_optimal_size
        counter = 0
        open(file_out, "w").close()
        with open(file_in, "rb") as f:
            for piece in read_in_chunks(f, ch_optimal_size):
                with open(file_out, "ab") as fout:
                    fout.write(piece)
                counter += p_step
                QCoreApplication.processEvents()
        return True

class QuietHandler(SimpleHTTPRequestHandler):
    """Web server handler, which will not write any message
    in python console. As a result, no need to open python console
    in QGIS in order to make plugin work
    """

    def log_message(self, format, *args):
        pass

class HttpDaemon(QtCore.QThread):
    """Simple web server class
    """

    def __init__(self, parent, path):
        super(QThread, self).__init__()
        self.server_path = path
        self.server = None  # Initialize server attribute

    def run(self):
        os.chdir(self.server_path)
        self.server = HTTPServer((HOST, PORT), QuietHandler)
        self.server.serve_forever()
        QgsMessageLog.logMessage("Serving server")

    def stop(self):
        if self.server:
            self.server.shutdown()
            self.server.socket.close()
            QgsMessageLog.logMessage("Closing socker")

    def __del__(self):
        self.stop()  # Ensure server is stopped and socket is closed when instance is deleted
        QgsMessageLog.logMessage("Server stoped")

        
